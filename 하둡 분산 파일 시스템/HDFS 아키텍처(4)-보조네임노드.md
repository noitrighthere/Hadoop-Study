### 보조네임노드

네임노드는 메타데이터를 메모리에서 처리한다. 하지만 메모리에만 데이터를 유지할 경유 **서버가 재부팅될 경우 모든 메타데이터가 유실될 수 있다.** HDFS는 이러한 문제점을 극복하기 위해 `editslog`와 `fsimage`라는 두 개의 파일을 생성한다.

- editslog: **HDFS의 모든 변경 이력을 저장한다.**
- fsimage: **메모리에 저장된 메타데이터의 파일 시스템 이미지를 저장한 파일이다.**

네임노드가 구동될 경우, 다음과 같은 단계로 두 개의 파일을 사용한다.

1. 네임노드가 구동되면 로컬에 저장된 fsimage와 editslog를 조회한다.

2. 메모리에 fsimage를 로딩해 파일 시스템 이미지를 생성한다.

3. 메모리에 로딩된 파일 시스템 이미지에 editslog에 기록된 변경 이력을 적용한다.

4. 메모리에 로딩된 파일 시스템 이미지를 이용해 fsimage 파일을 갱신한다.

5. editslog를 초기화한다.

6. 데이터노드가 전송된 블록리포트를 메모리에 로딩된 파일 시스템 이미지에 적용한다.

만약 editslog가 커지면 fsimage를 만드는 데 시간이 많이 소요하게 된다.  

이러한 문제점을 해결하기 위해 HDFS는 **보조네임노드(Secondary Name Node)라는 노드를 제공**한다. 보조네임노드는 fsimage를 갱신해준다. 이러한 작업을 체크포인트(checkpoint)라고 한다. 그래서 흔히 보조네임노드를 체크포인팅 서버라고도 한다. 

![체크포인팅 단계](/img/하둡_분산_파일_시스템/체크포인팅_단계.png "체크포인팅 단계")

위 그림의 각 단계는 다음과 같이 진행된다.

1. 보조네임노드는 네임노드에게 editslog를 로링할 것을 요청한다. *로그 롤링은 현재 로그 파일의 이름을 변경하고, 원래 이름으로 새 로그 파일을 만드는 것이다.*

2. 네임노드는 기존 editslog를 롤링한 후, editslog.new를 생성한다.

3. 보조네임노드는 네임노드에 저장된 롤링된 editslog와 fsimage를 다운로드한다.

4. 보조네임노드는 다운받은 fsimage를 메모리에 로딩하고, editslog에 있는 변경 이력을 메모리에 로이도니 파일 시스템 이미지에 적용한다. 메모리 갱신이 완료되면 새로운 fsimage를 생성하며, 이 파일을 체크포인팅할 때 사용한다. 이때 파일명은 fsimage.ckpt로 생성된다.

5. 보조네임노드는 fsimage.ckpt를 네임노드에게 전송한다.

6. 네임노드는 로컬에 저장돼 있던 fsimage를 보조네임노드가 전송한 fsimage.ckpt로 변경한다. 그리고 editslog.new 파일명을 editslog로 변경한다.

보조네임노드는 네임노드의 백업이 아니고 단순히 fsimage를 줄여 주는 역할만 한다. fsimage가 너무 커서 네임노드가 메모리에 로딩되지 못하는 경우를 예방하기 위해 사용되는 것이다.